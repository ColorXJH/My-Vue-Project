<!DOCTYPE html><!--!DOCTYPE html5声明在第一行-->
<html lang="en"><!--基本结构为html包含head和body-->
<head>
    <meta charset="UTF-8"><!--字符集-->
    <title>文档标题</title>

</head>
<body>
this is use token to push 2
文档内容  视频(video)与音频 (audio) 。
html=hypertext marked language
文件后缀名为.html或者.htm
html大小写不敏感
<h1>这是一个标题，1-6逐渐变小</h1>
<p>这是一个段落</p>
<img id="scream" src="../picture/001.jpg" alt="The Scream" width="100px" height="100px" ><p>Canvas:</p>
<canvas id="myCanvas" width="200" height="300" style="border: 1px solid #000000;"></canvas>
<br/>
//html内联svg
//SVG 指可伸缩矢量图形 (Scalable Vector Graphics)
将svg直接嵌入倒html5页面
<br/>
<svg xmlns="http://www.w3.org/2000/svg" version="1.1" height="190">
    <polygon points="100,10 40,180 190,60 10,60 160,180"
             style="fill:lime;stroke:purple;stroke-width:5;fill-rule:evenodd;"/>
</svg>

<br/>
svg与canvas的区别：<br/>
svg是一种使用xml描述2d图形的语言，canvas通过javascript来绘制2d图形<br/>
SVG 基于 XML，这意味着 SVG DOM 中的每个元素都是可用的。您可以为某个元素附加 JavaScript 事件处理器。<br/>
在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。<br/>
Canvas 是逐像素进行渲染的。在 canvas 中，一旦图形被绘制完成，它就不会继续得到浏览器的关注。<br/>
如果其位置发生变化，那么整个场景也需要重新绘制，包括任何或许已被图形覆盖的对象。<br/>

html5与MathML(数学标记语言，可以在html文档中使用，对应标签<math></math>)
<math xmlns="http://www.w3.org/1998/Math/MathML">
    <mrow>
        <msup><mi>a</mi><mn>2</mn></msup>
        <mo>+</mo>
        <msup><mi>b</mi><mn>2</mn></msup>
        <mo>=</mo>
        <msup><mi>c</mi><mn>2</mn></msup>
    </mrow>
</math>
<br/>

//html5拖放
拖放是一种常见的特性，即抓取对象以后拖到另一个位置。
在 HTML5 中，拖放是标准的一部分，任何元素都能够拖放。

<div id="div1" ondrop="drop(event)" style="width: 150px;height:150px ;border: 1px solid "
     ondragover="allowDrop(event)"></div>

<div id="div2"  ondrop="drop(event)" ondragover="allowDrop(event)" style="width: 150px;height:150px ;border: 1px solid ">
<img id="drag1" src="../picture/001.jpg" draggable="true"
     ondragstart="drag(event)" width="100" height="100">
</div>

</body>

<script>
    //canvas坐标
    var c=document.getElementById("myCanvas");
    var ctx=c.getContext("2d");//方法返回一个用于在画布上绘图的环境,当前唯一的合法值是 "2d"
    ctx.fillStyle="#FF0000";//设置fillStyle属性可以是CSS颜色，渐变，或图案
    ctx.fillRect(0,0,150,75);//fillRect(x,y,width,height) 方法定义了矩形当前的填充方式。在画布上绘制 150x75 的矩形，从左上角开始 (0,0)。

    //canvas 路径
    //定义开始坐标(0,0), 和结束坐标 (200,100). 然后使用 stroke() 方法来绘制线条:
    ctx.moveTo(0,0);
    ctx.lineTo(200,100);
    ctx.stroke();

    //canvas 绘制圆
    ctx.beginPath();
    ctx.arc(95,50,40,0,2*Math.PI);//arc(x,y,r,start,stop)
    ctx.stroke();

    //canvas 文本

    ctx.font="30px Arial";//定义字体
    ctx.fillText("hello world",100,200);// fillText(text,x,y) - 在 canvas 上绘制实心的文本
    ctx.strokeText("clear love",20,50);//strokeText(text,x,y) - 在 canvas 上绘制空心的文本

    //canvas 渐变
    //create gradient 创建渐变
    var grd=ctx.createLinearGradient(0,0,200,0);//createLinearGradient(x,y,x1,y1) - 创建线条渐变
    grd.addColorStop(0,"red");
    grd.addColorStop(1,"white");
    //fill with gradient 填充渐变
    ctx.fillStyle=grd;
    ctx.fillRect(10,100,150,80);


   /* var grd2=ctx.createRadialGradient(75,50,5,100,70,100);//createRadialGradient(x,y,r,x1,y1,r1) - 创建一个径向/圆渐变
    grd2.addColorStop(0,"red");
    grd2.addColorStop(1,"white");
    ctx.fillStyle=grd2;
    ctx.fillRect(10,100,150,80);*/

    //canvas 图像
    var img=document.getElementById("scream");
    //ctx.drawImage(img,10,10);
    img.onload = function() {
        ctx.drawImage(img,20,20,100,100);//context.drawImage(img,x,y);context.drawImage(img,x,y,width,height);
    }


    //htm5:拖放
    //1：draggable="true"设置元素可拖放
    //2：拖动什么 - ondragstart 和 setData()
    //3；放到何处 - ondragover
    //默认地，无法将数据/元素放置到其他元素中。如果需要设置允许放置，我们必须阻止对元素的默认处理方式。
    //这要通过调用 ondragover 事件的 event.preventDefault() 方法：


    function allowDrop(ev){
        ev.preventDefault();
    }
    function drag(ev){
        ev.dataTransfer.setData("Text",ev.target.id);//在这个例子中，数据类型是 "Text"，值是可拖动元素的 id ("drag1")。
    }
    function drop(ev){
        ev.preventDefault();
        var data=ev.dataTransfer.getData("Text");
        ev.target.appendChild(document.getElementById(data));
    }
</script>
</html>